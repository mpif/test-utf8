1. java.util.concurrent.CountDownLatch
【简单介绍】：
	CountDownLatch类是一个同步计数器，构造时传入int参数，该参数就是计数器的初始值，每调用一次countDown()方法，计数器减1，
计数器大于0时，await()方法会阻塞程序继续执行；
【适用场景】：
	如：开5个线程去下载，当5个线程都执行完了才算下载成功!


2. java.util.concurrent.CyclicBarrier
【简单介绍】：
	CyclicBarrier是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点（common barrier point）。
在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时CyclicBarrier很有用。因为该barrier在释放
等待线程后可以重用，所以称它为循环的barrier。
【适用场景】：
	我们需要统计全国的业务数据。其中各省的数据库是独立的，也就是说按省分库。并且统计的数据量很大，统计过程也比较慢。
为了提高性能，快速计算。我们采取并发的方式，多个线程同时计算各省数据，每个省下面有用多线程，最后再汇总统计全国数据（各省数据的总和）。
如这种情况下，每个省一个线程，全国各省并发统计数据，当这组线程统计完成之后(await的数量到达了设定的数量后)，才会运行负责统计全国数据的线程(即构造方法中设置的Runnable对象)。


3. java.util.concurrent.Semaphore
【简单介绍】：
	Semaphore类是一个计数信号量，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个acquire(),然后再获取该许可。
每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。
【适用场景】：
	就像一个排队进入上海博物馆一样，放几个人等一下，有几个人走了然后再放几个人进入(比如走了3个就可以有3个进入)，就像是一种排队机制。

























































































































